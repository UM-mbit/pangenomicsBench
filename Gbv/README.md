# Building Gbv
1. Ensure that the environment variable `VTUNE_HOME` points to the vtune
   directory (e.g. `export VTUNE_HOME=/opt/intel/oneapi/vtune/latest`). This is
   tested with the compiler shipped in the GraphAligner conda environment
   (g++-11)
2. create the GraphAligner conda environment
   `cd deps/GraphAligner && conda env create -f CondaEnvironment_linux.yml && cd ../..`
3. activate the conda environment
   `conda activate GraphAligner`
4. build the kernel
   `make -j`

# Running Gbv
Run the kernel with the command
`./bin/gbv <path to data> <num iterations, or blank>`
Example with `$KERNEL_DATA` pointing to the kernel data directory
`./bin/gbv $KERNEL_DATA/Gbv/Mc1e3Reads 30`:

# Generating Inputs  
Mc1e3Reads was generated by running a hacked version of GraphAligner
(`https://github.com/kaplannp/GraphAligner/tree/dumper`)
on the MinigraphCactus pagnenome graph from HPRC V1 for chromosome 20 with 
pacbio reads from HPRC V1 which were filtered to chromosome 20.

# Understanding Outputs
Outputs are in json format. One json object per output. The objects have the
format:
```json
{
  "index": <theIterationNumber>,
  "traces": [
    {
      "graphChars": [ #the characters in the sequence in the graph
        <asciiEncodingOfBasePair>,
        <asciiEncodingOfBasePair>,
        ...
      ]
      "nodeId": [ #the node the character is from
        <nodeId>,
        <nodeId>,
        ...
      ]
      "nodeOffset": [ #offset in the node. With nodeId gives loc of char
        <nodeOffset>,
        <nodeOffset>,
        ...
      ]
      "score": <score>, #alignment score
      "seqChars": [ #sequence character being matched
        <asciiEncodingOfBasePair>,
        <asciiEncodingOfBasePair>,
        ...
      ]
    } 
  ]
}
```
