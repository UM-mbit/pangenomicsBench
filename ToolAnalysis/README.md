## STEPS
1. Tool analysis is run on the unmodified tools[^1]. These can be found in the
   `Code` directory. Each tool has documentation in its respective github
   repository and readme. Make sure to build from source and compile with debug
   information. NOTE: Minigraph-Cactus does not require debug info, and PGGB
   can be installed via conda instead of building from source `conda install -c
   bioconda -c conda-forge pggb`.
2. Download the data from our server into this directory and extract it to Data/
   using the commands:
   `wget https://genomicsbench.eecs.umich.edu/ToolDataPangenomicsBench.tar.gz && tar -xvzf ToolDataPangenomicsBench.tar.gz`
3. Install Vtune if not already present on the system. Docs to install vtune are 
   found [here](https://www.intel.com/content/www/us/en/docs/vtune-profiler/installation-guide/2023-1/overview.html).
   The `vtune` executable 
   (`/opt/intel/oneapi/vtune/latest/bin64/vtune` for a most installs) must be 
   in the path to run the script in step 4.  
4. The __Seq2Graph timing breakdown__ (Fig. 2 of paper) are generated by running vtune on
   the tools. Run `bash runVtune.sh` to collect the vtune hotspots profiles. 
   The profiles will appear in the `PipelineResults` directory. 

   The stages of the __pangenome graph building pipeline__ (bottom of Fig. 3 of
   paper) are more modular, so we run each step independently. To
   generate these profiles, follow the instructions in the `README.md` in
   `PipelineResults/Pggb` and `PipelineResults/MinigraphCactus`.
5. To collect ThreadScaling run the thread scaling script
   `bash runScaling.sh`.
   This will produce logs in the ThreadScaling/Logs directory and timing results
   in ThreadScaling/Timing.


[^1]: For odgi layout (PGSGD kernel) we use the cache-optimized implementation
    from [Li et al.](https://doi.org/10.1109/SC41406.2024.00035)
